<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模块化设计与依赖注入：构建可维护的软件系统</title>
      <link href="/2024/06/13/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/06/13/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化设计的本质"><a href="#模块化设计的本质" class="headerlink" title="模块化设计的本质"></a>模块化设计的本质</h1><p>现代软件系统日益复杂，如何构建易于维护、测试和扩展的系统架构？模块化设计给出了答案。让我们通过一个生动的类比来理解这一概念。</p><p>想象一下现代汽车的制造过程：发动机、变速箱、车身、电子控制系统等都是独立的模块。不同团队可以并行开发这些模块，最终通过标准接口组装成完整的汽车。这种模块化方法带来了显著优势：</p><ol><li><strong>独立开发</strong>：各团队专注于自己的模块，不互相干扰</li><li><strong>质量保证</strong>：每个模块都可以独立测试和验证</li><li><strong>灵活替换</strong>：只要遵循接口规范，模块可以自由升级或替换</li><li><strong>复用性强</strong>：标准化的模块可以用于不同型号的车型</li></ol><p>软件架构设计与之惊人地相似。通过定义清晰的接口和职责边界，我们可以将复杂系统分解为可管理的模块。这些接口可能是：</p><ul><li>微服务间的 API 契约（如 RESTful、gRPC）</li><li>应用内的抽象接口（如编程语言中的 interface）</li><li>模块间的消息协议（如事件总线、消息队列）</li></ul><h1 id="从”零件”到”组件”：构建可靠的软件模块"><a href="#从”零件”到”组件”：构建可靠的软件模块" class="headerlink" title="从”零件”到”组件”：构建可靠的软件模块"></a>从”零件”到”组件”：构建可靠的软件模块</h1><h2 id="常见的模块设计误区"><a href="#常见的模块设计误区" class="headerlink" title="常见的模块设计误区"></a>常见的模块设计误区</h2><p>很多开发者在设计模块时往往过于关注实现细节，而忽视了模块的可复用性。例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反面示例：强耦合的设计</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">    cache *redis.Client</span><br><span class="line">    logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span></span> CreateUser(user *User) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 直接操作具体的数据库实现</span></span><br><span class="line">    <span class="keyword">return</span> s.db.Exec(<span class="string">&quot;INSERT INTO users ...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计存在严重问题：</p><ol><li><strong>测试困难</strong>：无法轻松替换外部依赖</li><li><strong>强耦合</strong>：与具体技术实现绑定</li><li><strong>难以扩展</strong>：更换存储方案需要大量改动</li></ol><h2 id="走向清晰的模块边界"><a href="#走向清晰的模块边界" class="headerlink" title="走向清晰的模块边界"></a>走向清晰的模块边界</h2><p>让我们重构上面的例子，应用依赖注入和接口抽象：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义清晰的接口契约</span></span><br><span class="line"><span class="keyword">type</span> UserRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(user *User) <span class="type">error</span></span><br><span class="line">    FindByID(id <span class="type">string</span>) (*User, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">    Info(msg <span class="type">string</span>, fields ...Field)</span><br><span class="line">    Error(msg <span class="type">string</span>, fields ...Field)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务服务依赖于抽象接口</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">    repo   UserRepository</span><br><span class="line">    logger Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(repo UserRepository, logger Logger)</span></span> *UserService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserService&#123;</span><br><span class="line">        repo:   repo,</span><br><span class="line">        logger: logger,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span></span> CreateUser(user *User) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := s.repo.Create(user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.logger.Error(<span class="string">&quot;failed to create user&quot;</span>, Field(<span class="string">&quot;error&quot;</span>, err))</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    s.logger.Info(<span class="string">&quot;user created&quot;</span>, Field(<span class="string">&quot;id&quot;</span>, user.ID))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计带来的好处：</p><ol><li><strong>关注点分离</strong>：业务逻辑与技术实现解耦</li><li><strong>易于测试</strong>：可以注入 mock 实现进行单元测试</li><li><strong>灵活替换</strong>：存储层可以轻松切换（MySQL、MongoDB、内存数据库等）</li></ol><h1 id="构建清晰的系统架构"><a href="#构建清晰的系统架构" class="headerlink" title="构建清晰的系统架构"></a>构建清晰的系统架构</h1><h2 id="分层架构设计"><a href="#分层架构设计" class="headerlink" title="分层架构设计"></a>分层架构设计</h2><p>推荐采用以下项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── cmd/</span><br><span class="line">│   └── main.go           # 应用入口，负责依赖装配</span><br><span class="line">├── internal/</span><br><span class="line">│   ├── domain/          # 核心业务模型和接口定义</span><br><span class="line">│   │   ├── user.go</span><br><span class="line">│   │   └── repository.go</span><br><span class="line">│   ├── service/         # 业务逻辑实现</span><br><span class="line">│   │   └── user.go</span><br><span class="line">│   └── infrastructure/  # 外部依赖适配器</span><br><span class="line">│       ├── mysql/</span><br><span class="line">│       └── logger/</span><br><span class="line">└── pkg/                 # 可重用的公共组件</span><br></pre></td></tr></table></figure><h2 id="依赖注入的最佳实践"><a href="#依赖注入的最佳实践" class="headerlink" title="依赖注入的最佳实践"></a>依赖注入的最佳实践</h2><ol><li><p><strong>依赖倒置原则</strong>：</p><ul><li>高层模块不应依赖低层模块，两者都应依赖于抽象</li><li>抽象不应依赖于细节，细节应依赖于抽象</li></ul></li><li><p><strong>构造函数注入</strong>：</p><ul><li>通过构造函数明确声明依赖</li><li>避免使用全局变量或服务定位器</li></ul></li><li><p><strong>统一的依赖管理</strong>：</p><ul><li>在应用入口处集中配置依赖</li><li>使用依赖注入容器简化装配（可选）</li></ul></li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基础设施层</span></span><br><span class="line">    db := mysql.NewConnection(config.DBConfig)</span><br><span class="line">    logger := zap.NewProduction()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储层适配器</span></span><br><span class="line">    userRepo := mysql.NewUserRepository(db)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务服务装配</span></span><br><span class="line">    userService := service.NewUserService(userRepo, logger)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// API 层</span></span><br><span class="line">    handler := api.NewUserHandler(userService)</span><br><span class="line">    <span class="comment">// ... 启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模块化设计与依赖注入是构建可维护软件系统的重要基石。通过：</p><ul><li>定义清晰的模块边界和接口契约</li><li>应用依赖注入解耦模块依赖</li><li>遵循清晰的分层架构</li></ul><p>我们可以构建出易于测试、维护和扩展的软件系统。这些原则不仅适用于单体应用，在微服务架构中同样重要。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Robert C. Martin,《Clean Architecture》</li><li>Martin Fowler,《Patterns of Enterprise Application Architecture》</li><li>Vaughn Vernon,《Implementing Domain-Driven Design》</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解并发编程</title>
      <link href="/2024/02/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/02/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>并发的核心在于通过多线程和多进程，在不同 CPU 核心上并行执行任务。为了提高计算机性能，硬件和软件设计时需平衡 CPU、内存和 I&#x2F;O 三者之间的速度差异，这带来了三个主要问题：可见性、有序性和原子性。</p><ol><li><strong>可见性</strong>: CPU 和内存间的速度差异导致了多级缓存的使用。CPU 中的数据不会立即写回主内存，造成数据在不同线程或处理器之间不一致。</li><li><strong>有序性</strong>: 编译器和处理器为了优化性能可能会重排指令，这可能破坏程序原本的顺序依赖关系。</li><li><strong>原子性</strong>:CPU 与 I&#x2F;O 设备的速度差距促使操作系统引入进程和线程的概念来复用 CPU 资源，但这也可能导致对共享资源的非原子访问问题。</li></ol><p>为解决这些问题，应用程序中需要加入同步原语：</p><ul><li><strong>内存屏障</strong>确保指令按预定顺序执行，解决有序性问题。</li><li><strong>缓存一致性协议</strong>如 MESI 确保所有处理器看到的是最新的数据，解决可见性问题。</li><li><strong>锁机制</strong>保证对共享资源的安全访问，解决原子性问题。</li></ul><p>总之，并发编程的目标是通过合理运用这些同步技术，编写出高效且正确的程序。</p><h2 id="2-并发模型"><a href="#2-并发模型" class="headerlink" title="2. 并发模型"></a>2. 并发模型</h2><p>常见的并发模型包括多线程、多进程和协程，每种都有其独特的优势与适用场景。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>线程是操作系统调度的基本单元。在一个多核CPU环境中，多线程应用可以并行运行于不同的核心上。</li><li>同一进程内的多个线程共享内存空间，使得数据交换变得简单直接。</li><li>但是，当多个线程同时访问同一块内存区域时，如果没有妥善处理可见性、有序性和原子性问题，则可能导致线程安全问题。</li></ul><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><ul><li>相较于多线程，多进程提供了更高级别的隔离和安全性，因为每个进程拥有独立的地址空间。</li><li>这种方式避免了线程间因共享资源而可能引发的安全隐患。</li><li>不过，由于需要维护额外的上下文信息，多进程模型通常会消耗更多的系统资源（如CPU时间和内存）。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li>协程是一种轻量级的用户态“线程”，它允许程序以极低的成本创建大量并发任务。</li><li>Go语言中的goroutine和Java的虚拟线程都是协程概念的具体实现。</li><li>相比传统操作系统线程，协程减少了上下文切换的开销，使得单个应用程序能够支持数以万计甚至更多的并发执行单位。（在 Golang 中启动一个 goroutine 仅需约2KB的内存，而 Java 的一个线程至少也需要大约2MB。）</li></ul><p>综上所述，选择合适的并发模型对于构建高效且可靠的软件系统至关重要。根据应用场景的需求不同，开发者可以选择最适合当前需求的并发策略来优化性能与资源利用效率。</p><h2 id="3-并发设计模式"><a href="#3-并发设计模式" class="headerlink" title="3. 并发设计模式"></a>3. 并发设计模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Q1: 为了确保消息的有序消费，Kafka 的设计规定一个分区（partition）只能被单个消费者消费，而不能被多个消费者同时消费。然而，在实际应用中，许多场景并不需要严格的消费顺序，反而更加关注消费性能。如果在不调整分区数量的前提下，如何提高并发消费速度呢？<br>A1: </p><ol><li>可以将从 kafka poll 下来的消息，发送到多个消费 worker (并发) 中进行消费逻辑的处理，</li><li>worker 处理完后将消息的 offset 信息发送到本地提交器</li><li>提交器需要保证 offset 的提交是按 partition 顺序提交的。不能乱序，也不能跳过。</li></ol><p>Q2: 提交器可以选择什么数据结构来保证 offset 的分区有序性？<br>A2: 在有插入、删除、查询，而且要求保序的场景下，可以选择 SKIPLIST 或 Red-Black Tree。这两种数据结构比较均衡，插入、删除、查询的复杂度都能做到 O(nlog(n))。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><pre class="mermaid">flowchart TD    Kafka -->|Poll| Dispatcher    Dispatcher --> Worker1    Dispatcher --> Worker2    Dispatcher --> Worker3    Worker1 -->|Mark| Committer    Worker2 -->|Mark| Committer    Worker3 -->|Mark| Committer    Dispatcher -->|Put| Committer</pre><ol><li>Dispatcher 周期性的将 kafka 中的数据 poll 下来并分发给并发的 worker</li><li>Dispatcher 在发送 worker 前需要先将 topic、partition、offset 信息 put 到 Committer 中的 SKIPLIST</li><li>worker 处理完消费逻辑向 Committer 标记消费状态</li><li>Committer 定期按顺序提交已消费的 offset (不重、不漏、更不能跳过没有标记消费的 offset 信息)</li></ol><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h4 id="基于消息通信-Lock-Free"><a href="#基于消息通信-Lock-Free" class="headerlink" title="基于消息通信 (Lock Free)"></a>基于消息通信 (Lock Free)</h4><p>基于通信的并发模型，是程序世界对实现世界的模拟。现实世界是一个并发的世界。如进入一家早餐店就餐，顾客、厨师、服务员各自在做各自的事情，但是又通过信息的传递紧密的联系在一起。基于通信的并发非常自然而且无锁，遇到复杂的并发场景时可以考虑使用这种模型。Erlang 中的 Actor 模型与 Golang 中的 CSP 模型都是基于消息通信的。两个模型的侧重点有些微不同，Actor 模型强调的是对象内部的队列，CSP 模型强调对象之间的队列。</p><p><strong>Actor 模型</strong> </p><ol><li>Dispatcher、Worker、Committer 内部都存在队列</li><li>Dispatcher、Worker、Committer 都实现了 Run Stop 方法</li><li>启动 Run 方法后各个对象都开始消费内部队列的消息</li><li>Dispatcher 收到消息后发送到 Worker, Worker 将消息放在内部队列中，Worker 不停的处理消息。处理完成后发送给 Committer, Committer 也将收到的消息存放在内部队列中。Committer 的 Run 会进行提交处理</li><li>程序出错或者优雅退出时，需要 Consumer 协调各个并发对象依次 Stop<br>Actor 模型的关键就是利用协调者 (Consumer) 执行各个对象的 Run 方法(开启轻量级进程或者协程)，在遇到错误或者主动退出时能正确调用 Stop 各个对象执行的任务。</li></ol><p><strong>CSP 模型</strong></p><ol><li>Dispatcher -&gt; Worker -&gt; Committer （’-&gt;’ 表示 channel）</li><li>Dispatcher 启动，将 kafka 的消息 poll 到 channel_1 中</li><li>Worker 消费 channel_1 中的数据，处理完成发送到 channel_2 中</li><li>Committer 消费 channel_2 中的数据</li><li>出现错误由 context 协调退出并抛出错误。正常退出则利用 channel close 机制</li></ol><pre class="mermaid">graph LR    %% 定义节点    Dispatcher[Dispatcher Goroutine]    subgraph Workers [Workers]        direction TB        Worker1((Worker 1 <i>Goroutine</i>))        Worker2((Worker 2 <i>Goroutine</i>))        WorkerN((Worker N <i>Goroutine</i>))    end        Committer[Committer Goroutine]    %% 定义通道    channel_1[channel_1]    channel_2[channel_2]    %% 连接节点与通道    Dispatcher -->|poll| channel_1    channel_1 -.-> Worker1    channel_1 -.-> Worker2    channel_1 -.-> WorkerN    Worker1 -->|processed data| channel_2    Worker2 -->|processed data| channel_2    WorkerN -->|processed data| channel_2    channel_2 -->|consume| Committer</pre><h4 id="基于共享内存-Lock"><a href="#基于共享内存-Lock" class="headerlink" title="基于共享内存 (Lock)"></a>基于共享内存 (Lock)</h4><p>线程与协程模型会共享进程中的变量，通常可以利用同步原语来保证并发程序的正确性。</p><p>Q1: 启动 10 个协程，在没有任何同步操作条件下每个协程对某个共享变量操作 100 次自增。结果会是 1000 吗?<br>A1: 可能会小于 1000, 因为计算的加法不是原子的。如果要保证原子性，需要加上同步原语</p><p>Q2: 同步原语有哪些？<br>A2: </p><ol><li>重量级锁: 又叫互斥锁、同步锁、悲观锁。性能最差，但能完全互斥</li><li>轻量级锁: 又叫自旋锁、无锁、CAS。自旋可能有性能问题。主要用于竞争较小的场景。</li><li>读写锁</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
