<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模块化设计与依赖注入</title>
      <link href="/2024/06/13/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/06/13/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化设计的本质"><a href="#模块化设计的本质" class="headerlink" title="模块化设计的本质"></a>模块化设计的本质</h1><p>汽车制造为我们提供了一个绝佳的模块化设计范例。一辆现代汽车由车身结构、轮胎、悬挂系统、动力总成以及中央控制系统等多个独立组件构成。在整车开发过程中，不同的工程团队负责各自的模块开发，这些模块都具备三个关键特性：</p><ol><li><strong>独立性</strong>：每个模块可以独立设计和生产</li><li><strong>可测试性</strong>：模块可以独立进行质量验证</li><li><strong>标准接口</strong>：模块之间通过预定义的接口实现无缝集成</li></ol><p>软件工程中的模块化设计与之极为相似。通过定义清晰的接口（interface），独立的软件模块得以协同工作，最终构建成一个完整的系统。这里的”接口”可以表现为多种形式：</p><ul><li>系统间：服务调用协议（如 RESTful API、Protocol Buffers）</li><li>系统内：代码层面的抽象类型（如 Go 语言中的 interface）</li></ul><h1 id="构建可靠的软件模块"><a href="#构建可靠的软件模块" class="headerlink" title="构建可靠的软件模块"></a>构建可靠的软件模块</h1><h2 id="独立性与可测试性的重要性"><a href="#独立性与可测试性的重要性" class="headerlink" title="独立性与可测试性的重要性"></a>独立性与可测试性的重要性</h2><p>设计软件模块时，应该避免创建过于特化的”零件”，而是要打造具有普遍适用性的”标准件”。以下是一个反面示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EmailService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(email *EmailService)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    client := kafka.New()</span><br><span class="line">    <span class="keyword">return</span> client.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码存在两个主要问题：</p><ol><li><strong>测试困难</strong>：由于在方法内部直接创建 Kafka 客户端，无法在测试时替换这个依赖</li><li><strong>耦合度高</strong>：EmailService 与具体的消息队列实现强绑定，缺乏灵活性</li></ol><h2 id="依赖注入的解决方案"><a href="#依赖注入的解决方案" class="headerlink" title="依赖注入的解决方案"></a>依赖注入的解决方案</h2><p>通过依赖注入，我们可以显著改善模块的设计：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象接口</span></span><br><span class="line"><span class="keyword">type</span> Broker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(msg <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构邮件服务</span></span><br><span class="line"><span class="keyword">type</span> EmailService <span class="keyword">struct</span> &#123;</span><br><span class="line">    broker Broker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailService</span><span class="params">(broker Broker)</span></span> *EmailService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EmailService&#123; broker: broker &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *EmailService)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> srv.broker.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计带来以下优势：</p><ol><li><strong>可测试性</strong>：可以轻松注入测试用的 mock 对象</li><li><strong>灵活性</strong>：支持不同的消息队列实现</li><li><strong>解耦</strong>：EmailService 不再依赖具体实现细节</li></ol><h1 id="系统架构与依赖管理"><a href="#系统架构与依赖管理" class="headerlink" title="系统架构与依赖管理"></a>系统架构与依赖管理</h1><h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><p>在实际项目中，建议采用以下分层结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── cmd</span><br><span class="line">│   └── main.go          // 程序入口，负责组件装配</span><br><span class="line">└── internal</span><br><span class="line">    └── app</span><br><span class="line">        ├── domain       // 核心业务逻辑和接口定义</span><br><span class="line">        └── infrastructure  // 接口实现和外部依赖适配</span><br></pre></td></tr></table></figure><h2 id="依赖注入原则"><a href="#依赖注入原则" class="headerlink" title="依赖注入原则"></a>依赖注入原则</h2><p>在使用依赖注入时，需要遵循以下关键原则：</p><ol><li><strong>面向接口编程</strong>：核心业务逻辑应该依赖于抽象接口而非具体实现</li><li><strong>依赖方向</strong>：外部依赖需要实现核心层定义的接口</li><li><strong>统一装配</strong>：在程序入口处统一进行依赖注入和系统装配</li></ol><p>这种架构设计的优势在于：</p><ul><li>业务逻辑与技术实现完全分离</li><li>系统具有更好的可维护性和可测试性</li><li>支持灵活的依赖替换和系统扩展</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1].《Clean Architecture》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解并发编程</title>
      <link href="/2024/02/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/02/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>并发的核心在于通过多线程和多进程，在不同 CPU 核心上并行执行任务。为了提高计算机性能，硬件和软件设计时需平衡 CPU、内存和 I&#x2F;O 三者之间的速度差异，这带来了三个主要问题：可见性、有序性和原子性。</p><ol><li><strong>可见性</strong>: CPU 和内存间的速度差异导致了多级缓存的使用。CPU 中的数据不会立即写回主内存，造成数据在不同线程或处理器之间不一致。</li><li><strong>有序性</strong>: 编译器和处理器为了优化性能可能会重排指令，这可能破坏程序原本的顺序依赖关系。</li><li><strong>原子性</strong>:CPU 与 I&#x2F;O 设备的速度差距促使操作系统引入进程和线程的概念来复用 CPU 资源，但这也可能导致对共享资源的非原子访问问题。</li></ol><p>为解决这些问题，应用程序中需要加入同步原语：</p><ul><li><strong>内存屏障</strong>确保指令按预定顺序执行，解决有序性问题。</li><li><strong>缓存一致性协议</strong>如 MESI 确保所有处理器看到的是最新的数据，解决可见性问题。</li><li><strong>锁机制</strong>保证对共享资源的安全访问，解决原子性问题。</li></ul><p>总之，并发编程的目标是通过合理运用这些同步技术，编写出高效且正确的程序。</p><h2 id="2-并发模型"><a href="#2-并发模型" class="headerlink" title="2. 并发模型"></a>2. 并发模型</h2><p>常见的并发模型包括多线程、多进程和协程，每种都有其独特的优势与适用场景。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>线程是操作系统调度的基本单元。在一个多核CPU环境中，多线程应用可以并行运行于不同的核心上。</li><li>同一进程内的多个线程共享内存空间，使得数据交换变得简单直接。</li><li>但是，当多个线程同时访问同一块内存区域时，如果没有妥善处理可见性、有序性和原子性问题，则可能导致线程安全问题。</li></ul><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><ul><li>相较于多线程，多进程提供了更高级别的隔离和安全性，因为每个进程拥有独立的地址空间。</li><li>这种方式避免了线程间因共享资源而可能引发的安全隐患。</li><li>不过，由于需要维护额外的上下文信息，多进程模型通常会消耗更多的系统资源（如CPU时间和内存）。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li>协程是一种轻量级的用户态“线程”，它允许程序以极低的成本创建大量并发任务。</li><li>Go语言中的goroutine和Java的虚拟线程都是协程概念的具体实现。</li><li>相比传统操作系统线程，协程减少了上下文切换的开销，使得单个应用程序能够支持数以万计甚至更多的并发执行单位。（在 Golang 中启动一个 goroutine 仅需约2KB的内存，而 Java 的一个线程至少也需要大约2MB。）</li></ul><p>综上所述，选择合适的并发模型对于构建高效且可靠的软件系统至关重要。根据应用场景的需求不同，开发者可以选择最适合当前需求的并发策略来优化性能与资源利用效率。</p><h2 id="3-并发设计模式"><a href="#3-并发设计模式" class="headerlink" title="3. 并发设计模式"></a>3. 并发设计模式</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Q1: 为了确保消息的有序消费，Kafka 的设计规定一个分区（partition）只能被单个消费者消费，而不能被多个消费者同时消费。然而，在实际应用中，许多场景并不需要严格的消费顺序，反而更加关注消费性能。如果在不调整分区数量的前提下，如何提高并发消费速度呢？<br>A1: </p><ol><li>可以将从 kafka poll 下来的消息，发送到多个消费 worker (并发) 中进行消费逻辑的处理，</li><li>worker 处理完后将消息的 offset 信息发送到本地提交器</li><li>提交器需要保证 offset 的提交是按 partition 顺序提交的。不能乱序，也不能跳过。</li></ol><p>Q2: 提交器可以选择什么数据结构来保证 offset 的分区有序性？<br>A2: 在有插入、删除、查询，而且要求保序的场景下，可以选择 SKIPLIST 或 Red-Black Tree。这两种数据结构比较均衡，插入、删除、查询的复杂度都能做到 O(nlog(n))。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><pre class="mermaid">flowchart TD    Kafka -->|Poll| Dispatcher    Dispatcher --> Worker1    Dispatcher --> Worker2    Dispatcher --> Worker3    Worker1 -->|Mark| Committer    Worker2 -->|Mark| Committer    Worker3 -->|Mark| Committer    Dispatcher -->|Put| Committer</pre><ol><li>Dispatcher 周期性的将 kafka 中的数据 poll 下来并分发给并发的 worker</li><li>Dispatcher 在发送 worker 前需要先将 topic、partition、offset 信息 put 到 Committer 中的 SKIPLIST</li><li>worker 处理完消费逻辑向 Committer 标记消费状态</li><li>Committer 定期按顺序提交已消费的 offset (不重、不漏、更不能跳过没有标记消费的 offset 信息)</li></ol><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h4 id="基于消息通信-Lock-Free"><a href="#基于消息通信-Lock-Free" class="headerlink" title="基于消息通信 (Lock Free)"></a>基于消息通信 (Lock Free)</h4><p>基于通信的并发模型，是程序世界对实现世界的模拟。现实世界是一个并发的世界。如进入一家早餐店就餐，顾客、厨师、服务员各自在做各自的事情，但是又通过信息的传递紧密的联系在一起。基于通信的并发非常自然而且无锁，遇到复杂的并发场景时可以考虑使用这种模型。Erlang 中的 Actor 模型与 Golang 中的 CSP 模型都是基于消息通信的。两个模型的侧重点有些微不同，Actor 模型强调的是对象内部的队列，CSP 模型强调对象之间的队列。</p><p><strong>Actor 模型</strong> </p><ol><li>Dispatcher、Worker、Committer 内部都存在队列</li><li>Dispatcher、Worker、Committer 都实现了 Run Stop 方法</li><li>启动 Run 方法后各个对象都开始消费内部队列的消息</li><li>Dispatcher 收到消息后发送到 Worker, Worker 将消息放在内部队列中，Worker 不停的处理消息。处理完成后发送给 Committer, Committer 也将收到的消息存放在内部队列中。Committer 的 Run 会进行提交处理</li><li>程序出错或者优雅退出时，需要 Consumer 协调各个并发对象依次 Stop<br>Actor 模型的关键就是利用协调者 (Consumer) 执行各个对象的 Run 方法(开启轻量级进程或者协程)，在遇到错误或者主动退出时能正确调用 Stop 各个对象执行的任务。</li></ol><p><strong>CSP 模型</strong></p><ol><li>Dispatcher -&gt; Worker -&gt; Committer （’-&gt;’ 表示 channel）</li><li>Dispatcher 启动，将 kafka 的消息 poll 到 channel_1 中</li><li>Worker 消费 channel_1 中的数据，处理完成发送到 channel_2 中</li><li>Committer 消费 channel_2 中的数据</li><li>出现错误由 context 协调退出并抛出错误。正常退出则利用 channel close 机制</li></ol><pre class="mermaid">graph LR    %% 定义节点    Dispatcher[Dispatcher Goroutine]    subgraph Workers [Workers]        direction TB        Worker1((Worker 1 <i>Goroutine</i>))        Worker2((Worker 2 <i>Goroutine</i>))        WorkerN((Worker N <i>Goroutine</i>))    end        Committer[Committer Goroutine]    %% 定义通道    channel_1[channel_1]    channel_2[channel_2]    %% 连接节点与通道    Dispatcher -->|poll| channel_1    channel_1 -.-> Worker1    channel_1 -.-> Worker2    channel_1 -.-> WorkerN    Worker1 -->|processed data| channel_2    Worker2 -->|processed data| channel_2    WorkerN -->|processed data| channel_2    channel_2 -->|consume| Committer</pre><h4 id="基于共享内存-Lock"><a href="#基于共享内存-Lock" class="headerlink" title="基于共享内存 (Lock)"></a>基于共享内存 (Lock)</h4><p>线程与协程模型会共享进程中的变量，通常可以利用同步原语来保证并发程序的正确性。</p><p>Q1: 启动 10 个协程，在没有任何同步操作条件下每个协程对某个共享变量操作 100 次自增。结果会是 1000 吗?<br>A1: 可能会小于 1000, 因为计算的加法不是原子的。如果要保证原子性，需要加上同步原语</p><p>Q2: 同步原语有哪些？<br>A2: </p><ol><li>重量级锁: 又叫互斥锁、同步锁、悲观锁。性能最差，但能完全互斥</li><li>轻量级锁: 又叫自旋锁、无锁、CAS。自旋可能有性能问题。主要用于竞争较小的场景。</li><li>读写锁</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
